/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include "stm32f103xb.h"
#include "LcdScreen.hpp"
#include "DelayTimer.hpp"
#include "GpioConfigurator.hpp"

#include "I2cRxTx.hpp"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


void InitClocks()
{
	// Use HSI = 8MHz
	// SYSCLK = HSI

	uint32_t temp = RCC->CR;
	temp &= ~(RCC_CR_PLLON | RCC_CR_CSSON | RCC_CR_HSEBYP | RCC_CR_HSEON);
	temp |= RCC_CR_HSEON;
	RCC->CR = temp;

	temp = RCC->CFGR;

	temp &= ~(RCC_CFGR_MCO);
	temp |= RCC_CFGR_MCO_SYSCLK;

	temp &= ~(RCC_CFGR_SW);
	temp |= RCC_CFGR_SW_HSI;

	// AHB = SYSCLK / 8
	temp &= ~(RCC_CFGR_HPRE);
	temp |= RCC_CFGR_HPRE_DIV8;

	// PCLK2 = SYSCLK / 1
	temp &= ~(RCC_CFGR_PPRE2);
	temp |= RCC_CFGR_PPRE2_DIV1;

	// PCLK1 = SYSCLK / 1
	temp &= ~(RCC_CFGR_PPRE1);
	temp |= RCC_CFGR_PPRE1_DIV1;

	RCC->CFGR = temp;
}

void ALTERNATIVE_FUNCTION_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
}

void PA_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
}

void PB_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
}


void PC_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
}

void InitPorts()
{
	ALTERNATIVE_FUNCTION_CLOCK_ENABLE();
	PA_CLOCK_ENABLE();
	PB_CLOCK_ENABLE();
	PC_CLOCK_ENABLE();
}





class MyClass
{
public:
	MyClass()
	{
	};
private:
};



class AM3220Sensor
{
public:
	AM3220Sensor()
	{
		I2cRxTx::Init();
	}

	void Read()
	{
		volatile uint8_t bbbb=12;
		for(;;)
		{
			if (bbbb != 12)
				break;

			//DelayTimer::DelayMilliSec(15);
			Acquisition();

			WakeCommand();
			if (!ReadCommand())
				continue;

			DelayTimer::DelayMilliSec(15);

			if (!GetReadData())
				continue;
		}




	}


private:
	void WakeCommand() const
	{
		// Wake sensor
		I2cRxTx::StartCondition();
		I2cRxTx::SendByte(0xB8);
		I2cRxTx::GetAcknowlegeBit(true);
		DelayTimer::DelayMicroSec(800);
		I2cRxTx::StopCondition();
	}

	bool ReadCommand() const
	{
		I2cRxTx::StartCondition();
		I2cRxTx::SendByte(0xB8);
		const bool ack0 = I2cRxTx::GetAcknowlegeBit(true);
		if (ack0 == true)
		{
			I2cRxTx::StopCondition();
			return false;
		}

		I2cRxTx::SendByte(0x03);
		const bool ack1 = I2cRxTx::GetAcknowlegeBit(true);
		if (ack1 == true)
		{
			I2cRxTx::StopCondition();
			return false;
		}

		I2cRxTx::SendByte(0x00);
		const bool ack2 = I2cRxTx::GetAcknowlegeBit(true);
		if (ack2 == true)
		{
			I2cRxTx::StopCondition();
			return false;
		}

		I2cRxTx::SendByte(0x04);
		const bool ack3 = I2cRxTx::GetAcknowlegeBit(true);
		if (ack3 == true)
		{
			I2cRxTx::StopCondition();
			return false;
		}

		I2cRxTx::StopCondition();
		return true;
	}


	bool GetReadData(/*uint8_t& resSize, uint8_t* result*/) const
	{
		I2cRxTx::StartCondition();
		I2cRxTx::SendByte(0xB9);
		const bool ack0 = I2cRxTx::GetAcknowlegeBit(true);
		if (ack0 == true)
		{
			I2cRxTx::StopCondition();
			return false;
		}

		uint8_t rx[8] = {0,0,0,0,0,0,0,0};

		// Clear to default
//		resSize = 0;
///		for(uint8_t i = 0; i < 8; ++i)
//		{
//			*(result + i) = 0x00;
//		}

		uint8_t rxCnt = 0;
		for(/*uint8_t rxCnt = 0*/; rxCnt < 8; ++rxCnt)
		{
			rx[rxCnt] = I2cRxTx::RecieveByte();
		    bool ack = false;

		    if (rxCnt != 7)
		    {
		    	ack = I2cRxTx::GetAcknowlegeBit(true);
		    }
		    else
		   	{
		   		ack = I2cRxTx::GetAcknowlegeBit(true);
		   	}

		    if (ack == true)
		    	break;
		}

		I2cRxTx::StopCondition();

		  LcdScreen::LcdClear();
		  LcdScreen::LcdToPos(0, 0);

		  //LcdScreen::LcdToPos(0, 0);

		  if (rxCnt == 0)
		  {
		  	LcdScreen::LcdPrint("No answ");
		  }
		  else
		  {
			  for(uint8_t i = 0; i < 4 && i < rxCnt; ++i)
			  {
				  LcdScreen::LcdPrintHex(rx[i]);
		  	  }
		  	  LcdScreen::LcdToPos(0, 1);
		      for(uint8_t i = 4; i < 8 && i < rxCnt; ++i)
    		  {
    			  LcdScreen::LcdPrintHex(rx[i]);
    		  }
		  }


		return true;
	}


	void Acquisition() const
	{
		DelayTimer::DelayMilliSec(2000);
	}

};


int main(void)
{
	InitClocks();
	InitPorts();
	DelayTimer::DelayMilliSec(1500);	// Wait for power on of LCD

	LcdScreen::LcdInit();
	//LcdInit();



	GpioConfigurator::GpioClockEnable(GPIOC);
	GpioConfigurator::SetGpioOutPushPull(GPIOC, 13);

/*
  uint32_t temp = GPIOC->CRH;
  temp &= ~(((uint32_t)0b1111) << 20);
  //temp |= (((uint32_t)0b0011) << 20);
  temp |= (((uint32_t)0b0111) << 20);
  GPIOC->CRH  = temp;
//  GPIOC->CRL |= (1 << 13);

//  GPIOC->CRL
*/

  {		// Test clock output on pin  MCO(PA8)
	  //RCC->APB2ENR |= (1 << 0) | (1 << 2);	// PA and AFIO clock enable:

	  uint32_t temp = GPIOA->CRH;
	  temp &= ~(((uint32_t)0b1111) << 0);
	  temp |= (((uint32_t)0b1011) << 0);
	  GPIOA->CRH  = temp;

//	  temp = RCC->CFGR;
//	  temp &= ~(((uint32_t)0b111) << 24);
//	  temp |= ((uint32_t)0b100) << 24;
//	  RCC->CFGR = temp;
  }

  LcdScreen::LcdPrint("Hello!!!");



  {	// @#$%#$^%@#$%@#$%@#$%@# AM2320 Sensor test @#%$@#%$@#$%@#%$@#%#$5

	  AM3220Sensor sens;

	  sens.Read();



  }	// @#$%#$^%@#$%@#$%@#$%@# AM2320 Sensor test @#%$@#%$@#$%@#%$@#%#$5





  I2cRxTx::Init();

  for(uint8_t tryCnt = 0;; ++tryCnt)
  {	// @#$@#$@#%@#$#@#$# I2C TEST @#$@#$@!#@!#@!#!#@!3

	  // Wake sensor
	  I2cRxTx::StartCondition();
	  I2cRxTx::SendByte(0xB8);
	  I2cRxTx::GetAcknowlegeBit();
	  DelayTimer::DelayMicroSec(800);
	  I2cRxTx::StopCondition();

	  DelayTimer::DelayMicroSec(1500);

//	  DelayTimer::DelayMicroSec(100);
	  // Fake write command
	  I2cRxTx::StartCondition();
	  I2cRxTx::SendByte(0xB8);

	  I2cRxTx::GetAcknowlegeBit(false);
	  I2cRxTx::SendByte(0x03);
	  I2cRxTx::GetAcknowlegeBit(false);
	  I2cRxTx::SendByte(0x00);
	  I2cRxTx::GetAcknowlegeBit(false);
	  I2cRxTx::SendByte(0x04);
	  I2cRxTx::GetAcknowlegeBit(false);
	  I2cRxTx::StopCondition();


	  // Get read back info


	  DelayTimer::DelayMicroSec(15000);
	  // Attempt to read
	  I2cRxTx::StartCondition();

	  I2cRxTx::SendByte(0xB9);
	  I2cRxTx::GetAcknowlegeBit(false);

	  DelayTimer::DelayMicroSec(1000);

	  I2cRxTx::SendByte(0x03);
	  I2cRxTx::GetAcknowlegeBit(false);

	  DelayTimer::DelayMicroSec(1000);

	  I2cRxTx::SendByte(0x00);
	  I2cRxTx::GetAcknowlegeBit(false);

	  DelayTimer::DelayMicroSec(1000);

	  I2cRxTx::SendByte(0x04);
	  I2cRxTx::GetAcknowlegeBit(false);

	  DelayTimer::DelayMicroSec(15000);





	  uint8_t byte0 =  I2cRxTx::RecieveByte();
	  I2cRxTx::GetAcknowlegeBit(false);

	  DelayTimer::DelayMicroSec(1000);

	  uint8_t byte1 =  I2cRxTx::RecieveByte();
	  I2cRxTx::GetAcknowlegeBit(false);

	  DelayTimer::DelayMicroSec(1000);

	  uint8_t byte2 =  I2cRxTx::RecieveByte();
	  I2cRxTx::GetAcknowlegeBit(false);

	  DelayTimer::DelayMicroSec(1000);

	  uint8_t byte3 =  I2cRxTx::RecieveByte();
	  I2cRxTx::GetAcknowlegeBit(false);

	  DelayTimer::DelayMicroSec(1000);

	  uint8_t byte4 =  I2cRxTx::RecieveByte();
	  I2cRxTx::GetAcknowlegeBit(false);

	  DelayTimer::DelayMicroSec(1000);

	  uint8_t byte5 =  I2cRxTx::RecieveByte();
	  I2cRxTx::GetAcknowlegeBit(false);

	  DelayTimer::DelayMicroSec(1000);

	  I2cRxTx::StopCondition();


	  DelayTimer::DelayMicroSec(50000);


	  LcdScreen::LcdClear();
//	  LcdScreen::LcdToPos(0, 0);
//	  LcdScreen::LcdPrintHex(ack);

	  LcdScreen::LcdToPos(6, 0);
	  LcdScreen::LcdPrintHex(tryCnt);

	  LcdScreen::LcdToPos(0, 0);
	  LcdScreen::LcdPrintHex(byte0);
	  LcdScreen::LcdPrintHex(byte1);

	  LcdScreen::LcdToPos(0, 1);
	  LcdScreen::LcdPrintHex(byte2);
	  LcdScreen::LcdPrintHex(byte3);
	  LcdScreen::LcdPrintHex(byte4);
	  LcdScreen::LcdPrintHex(byte5);

	  DelayTimer::DelayMilliSec(1000);
	  volatile uint8_t bbbb=12;
	  if (bbbb != 12)
		  break;



  } // @#$@#$@#%@#$#@#$# /I2C TEST @#$@#$@!#@!#@!#!#@!3





  //LcdClear();
  //LcdToPos(4,1);
  //LcdPrint("123");

  uint16_t cnt = 0;

  //DelayTimer::DelayMilliSec(10000);

  //TIM1->CNT = 10;


  //DelayTimer::DelayMicroSec(40000);

  while (1)
  {
	  //GPIOC->

	  LcdScreen::LcdToPos(0,1);
	  LcdScreen::LcdPrintNumber(cnt);
	  ++cnt;

	  //DelayTimer::DelayMicroSec(39);

	  GPIOC->BRR = 1 << 13;
	  //GPIOC->ODR = (((uint32_t)(1)) << 13);
	  //GPIOC->ODR &= ~(((uint32_t)(1)) << 13);

	  //DelayTimer::DelayMicroSec(1000);

	  //

	  //LcdDelayUs(30000);

	  DelayTimer::DelayMilliSec(50);



	  //GPIOC->ODR |= (((uint32_t)1) << 13);
	  //GPIOC->ODR = 0;
	  GPIOC->BSRR = 1 << 13;

	  DelayTimer::DelayMilliSec(50);


	  //HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);


	  //LcdDelayUs(30000);

    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}









