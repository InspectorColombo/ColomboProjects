#include "AdcRead.hpp"

//#include <stdint.h>
#include "stm32f103xb.h"

#include "GpioConfigurator.hpp"

#include "LcdScreen.hpp"


#define ADC_PORT	GPIOA		// PORT A
#define ADC_PIN		2			// PA2 (ADC1 INPUT2)



void Show(char* msg)
{
	LcdScreen::LcdClear();
	LcdScreen::LcdToPos(0, 0);
	LcdScreen::LcdPrint(msg);
}


AdcRead::AdcRead()
{
	Init();
}

void AdcRead::DelayMicroseconds(const uint32_t us)
{
	// ROUGH delay

	for(uint32_t usCnt = us; usCnt != 0; --usCnt)
	{
		asm("nop");
		asm("nop");
//		volatile asm("nop");
//		volatile asm("nop");
//		volatile asm("nop");
	}

}


void AdcRead::Init()
{
	// Set ADC port as analog input
	GpioConfigurator::GpioClockEnable(ADC_PORT);
	GpioConfigurator::SetGpioAnalogMode(ADC_PORT, ADC_PIN);


	uint32_t temp = RCC->CFGR;
	temp &= ~RCC_CFGR_ADCPRE_Msk;
	temp |= 0b00 << RCC_CFGR_ADCPRE_Pos; // PCLK / 2
	RCC->CFGR = temp;

	// Enable ADC1 clock
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN | RCC_APB2ENR_IOPAEN | RCC_APB2ENR_AFIOEN;

	// Turn ON ADC
	ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_EXTSEL_0 | ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_2;

	Show("Step1");

	// Wait ADC turning ON
	this->DelayMicroseconds(1000);

	Show("Step2");

//	// Re-calibrate ADC
//	ADC1->CR2 |= ADC_CR2_RSTCAL;
//
//	Show("Step3");
//
//	// Wait for calibration end
//	while ((ADC1->CR2 & ADC_CR2_RSTCAL) != 0x00)
//	{
//	}

	Show("Step4");

	// Set 13.5cycles for channel 2
	ADC1->SMPR2 = 0b010 << ADC_SMPR2_SMP2_Pos;

	Show("Step5");

	// Set only 1 channel (ADC_IN2) to conversion
	ADC1->SQR1 =  0b0001 << ADC_SQR1_L_Pos;
	ADC1->SQR2 =  0x00;
	ADC1->SQR3 =  2 << ADC_SQR3_SQ1_Pos;
}

uint16_t AdcRead::Read()
{
//	// Wait if there is conversion right now
//	while (ADC1->SR & ADC_SR_START)

	ADC1->SR &= ~ADC_SR_EOC;

/*
	if ((ADC1->CR2 & ADC_CR2_ADON) == 0)
	{
		Show("ADC1_OFF");
		this->DelayMicroseconds(1024*1024);
	}
	else
	{
		Show("ADC1_ON");
		this->DelayMicroseconds(1024*1024);
	}
*/

	ADC1->CR2 |= ADC_CR2_SWSTART;	// | ADC_CR2_ADON;

	Show("Step6");

	// wait for conversion end
	while ((ADC1->SR & ADC_SR_EOC) == 0)
	{
		uint32_t sr = ADC1->SR;
		LcdScreen::LcdClear();
		LcdScreen::LcdToPos(0,0);
		LcdScreen::LcdPrint("SR:");
		LcdScreen::LcdToPos(0,1);
		LcdScreen::LcdPrintHex((uint16_t)(sr));
		DelayMicroseconds(100000);
	}

	//DelayMicroseconds(1000);


	Show("Step7");

	uint16_t result = (uint16_t)(ADC1->DR & 0x0000FFFF);

	// Clear EOC bit if it is not cleared yet
	ADC1->SR &= ~ADC_SR_EOC;

	return result;
}






