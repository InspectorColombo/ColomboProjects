/*
 * LCD_SSD1306.hpp
 *
 *  Created on: Jan 12, 2025
 *      Author: Goggy
 */

#ifndef __LCD_SSD1306_HPP__
#define __LCD_SSD1306_HPP__

#include "stm32f103xb.h"
#include <stdint.h>

#include "I2cRxTx.hpp"
#include "LcdScreen.hpp"

namespace LcdDrivers
{

namespace SSD1306
{

class Driver
{
public:
	enum SlaveAddress
	{
		SA_0X7A,
		SA_0X78
	};

	// COMMANDS LIST
	const uint8_t SET_CONTRAST_CONTROL	= 0x81;

	explicit Driver(const SlaveAddress slaveAddress) : m_slaveAddress(0x00), m_error(false)
	{
		switch(slaveAddress)
		{
			case SA_0X7A: m_slaveAddress = 0x7A; break;
			case SA_0X78: m_slaveAddress = 0x78; break;
			default:
				return;	// Wrong address
		}
		I2cRxTx::Init();
		I2cRxTx::StopCondition();
	}

	void SetError(const bool toSet)
	{
		m_error = toSet;
	}

	bool GetError() const
	{
		return m_error;
	}








	void SendCommand(const uint8_t* commandPointer)
	{
		const uint8_t* cmdPtr = commandPointer;
		uint8_t commandLength = *cmdPtr;
		++cmdPtr;

		I2cRxTx::StartCondition();
		for(uint8_t cmdCnt = 0; cmdCnt < commandLength; ++cmdCnt)
		{
			const uint8_t byteToSend = (cmdCnt == 0) ? (*cmdPtr | m_slaveAddress) : (*cmdPtr);
			++cmdPtr;

			I2cRxTx::SendByte(byteToSend);
			const bool ack = I2cRxTx::GetAcknowlegeBit();
			if (ack)
			{
				SetError(true);
				break;
			}
		}
		I2cRxTx::StopCondition();
	}

	void SendData(const uint8_t* dataPointer, const uint16_t dataLength)
	{


		I2cRxTx::StartCondition();

		I2cRxTx::SendByte(m_slaveAddress | WRITE);
		bool ack = I2cRxTx::GetAcknowlegeBit();
		I2cRxTx::SendByte(DATA | CONT);
		ack |= I2cRxTx::GetAcknowlegeBit();
		I2cRxTx::SendByte(0x00);
		ack |= I2cRxTx::GetAcknowlegeBit();

		if (ack)
		{
			I2cRxTx::StopCondition();
			SetError(true);
			return;
		}

		const uint8_t* dataPtr = dataPointer;
		for(uint16_t dataCnt = 0; dataCnt < dataLength; ++dataCnt)
		{
			I2cRxTx::SendByte(*dataPtr);
			++dataPtr;
			if (I2cRxTx::GetAcknowlegeBit())
			{
				SetError(true);
				break;
			}
		}
		I2cRxTx::StopCondition();
	}


	void Test()
	{
		SendCommand(CHARGE_PUMP_ON);
		SendCommand(DISPLAY_ON);
		SendCommand(ENTIRE_DISPLAY_ON);
		SendCommand(SET_NORMAL_DISPLAY);

		const uint8_t tx4[128] =
		{
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
		};

		SendData(tx4, 128);


		if (GetError())
		{
			LcdScreen::LcdClear();
			LcdScreen::LcdToPos(0, 0);
			LcdScreen::LcdPrint("FAIL");
			return;
		}


		LcdScreen::LcdClear();
		LcdScreen::LcdToPos(0, 0);
		LcdScreen::LcdPrint("OK");



	}


private:
	uint8_t m_slaveAddress;
	bool	m_error;
	//I2cRxTx m_i2c;

	bool SendCommandOLD(const uint8_t* dataPtr, const uint8_t dataLength) const
	{
		I2cRxTx::StartCondition();

		const uint8_t* ptr = dataPtr;
		for(uint8_t dataCnt = 0; dataCnt < dataLength; ++dataCnt)
		{
			uint8_t data = *ptr;
			I2cRxTx::SendByte(data);
			bool ack = I2cRxTx::GetAcknowlegeBit();
			if (ack)
			{
				I2cRxTx::StopCondition();
				return false;
			}
			++ptr;
		}

		I2cRxTx::StopCondition();
		return true;
	}




};

}	//namespace SSD1306
}	//namespace LcdDrivers






#endif /* __LCD_SSD1306_HPP__ */
