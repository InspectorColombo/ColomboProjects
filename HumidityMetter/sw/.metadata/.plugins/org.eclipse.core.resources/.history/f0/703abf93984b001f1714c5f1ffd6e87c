/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include "stm32f103xb.h"
#include "LcdScreen.hpp"
#include "DelayTimer.hpp"
#include "GpioConfigurator.hpp"

#include "I2cRxTx.hpp"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


void InitClocks()
{
	// Use HSI = 8MHz
	// SYSCLK = HSI

	uint32_t temp = RCC->CR;
	temp &= ~(RCC_CR_PLLON | RCC_CR_CSSON | RCC_CR_HSEBYP | RCC_CR_HSEON);
	temp |= RCC_CR_HSEON;
	RCC->CR = temp;

	temp = RCC->CFGR;

	temp &= ~(RCC_CFGR_MCO);
	temp |= RCC_CFGR_MCO_SYSCLK;

	temp &= ~(RCC_CFGR_SW);
	temp |= RCC_CFGR_SW_HSI;

	// AHB = SYSCLK / 8
	temp &= ~(RCC_CFGR_HPRE);
	temp |= RCC_CFGR_HPRE_DIV8;

	// PCLK2 = SYSCLK / 1
	temp &= ~(RCC_CFGR_PPRE2);
	temp |= RCC_CFGR_PPRE2_DIV1;

	// PCLK1 = SYSCLK / 1
	temp &= ~(RCC_CFGR_PPRE1);
	temp |= RCC_CFGR_PPRE1_DIV1;

	RCC->CFGR = temp;
}

void ALTERNATIVE_FUNCTION_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
}

void PA_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
}

void PB_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
}


void PC_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
}

void InitPorts()
{
	ALTERNATIVE_FUNCTION_CLOCK_ENABLE();
	PA_CLOCK_ENABLE();
	PB_CLOCK_ENABLE();
	PC_CLOCK_ENABLE();
}





class MyClass
{
public:
	MyClass()
	{
	};
private:
};



int main(void)
{
	InitClocks();
	InitPorts();
	DelayTimer::DelayMilliSec(1500);	// Wait for power on of LCD

	LcdScreen::LcdInit();
	//LcdInit();



	GpioConfigurator::GpioClockEnable(GPIOC);
	GpioConfigurator::SetGpioOutPushPull(GPIOC, 13);

/*
  uint32_t temp = GPIOC->CRH;
  temp &= ~(((uint32_t)0b1111) << 20);
  //temp |= (((uint32_t)0b0011) << 20);
  temp |= (((uint32_t)0b0111) << 20);
  GPIOC->CRH  = temp;
//  GPIOC->CRL |= (1 << 13);

//  GPIOC->CRL
*/

  {		// Test clock output on pin  MCO(PA8)
	  //RCC->APB2ENR |= (1 << 0) | (1 << 2);	// PA and AFIO clock enable:

	  uint32_t temp = GPIOA->CRH;
	  temp &= ~(((uint32_t)0b1111) << 0);
	  temp |= (((uint32_t)0b1011) << 0);
	  GPIOA->CRH  = temp;

//	  temp = RCC->CFGR;
//	  temp &= ~(((uint32_t)0b111) << 24);
//	  temp |= ((uint32_t)0b100) << 24;
//	  RCC->CFGR = temp;
  }

  LcdScreen::LcdPrint("Hello!!!");





  {	// @#$@#$@#%@#$#@#$# I2C TEST @#$@#$@!#@!#@!#!#@!3

	  I2cRxTx::Init();
	  I2cRxTx::StartCondition();

	  I2cRxTx::SendByte(0xB8);
	  const bool ack0 = I2cRxTx::GetAcknowlegeBit();

	  I2cRxTx::SendByte(0x03);
	  const bool ack1 = I2cRxTx::GetAcknowlegeBit();

	  I2cRxTx::SendByte(0x00);
	  const bool ack2 = I2cRxTx::GetAcknowlegeBit();

	  I2cRxTx::SendByte(0x04);
	  const bool ack3 = I2cRxTx::GetAcknowlegeBit();


	  uint8_t byte0 =  I2cRxTx::RecieveByte();
	  const bool ack4 = I2cRxTx::GetAcknowlegeBit();
	  uint8_t byte1 =  I2cRxTx::RecieveByte();
	  const bool ack5 = I2cRxTx::GetAcknowlegeBit();
	  uint8_t byte2 =  I2cRxTx::RecieveByte();
	  const bool ack6 = I2cRxTx::GetAcknowlegeBit();
	  uint8_t byte3 =  I2cRxTx::RecieveByte();
	  const bool ack7 = I2cRxTx::GetAcknowlegeBit();

	  I2cRxTx::StopCondition();

	  LcdScreen::LcdClear();
	  LcdScreen::LcdToPos(0, 0);

	  if (ack0)
	  {
		  LcdScreen::LcdPrint("1");
	  }
	  else
	  {
		  LcdScreen::LcdPrint("0");
	  }

	  if (ack1)
	  {
		  LcdScreen::LcdPrint("1");
	  }
	  else
	  {
		  LcdScreen::LcdPrint("0");
	  }

	  if (ack2)
	  {
		  LcdScreen::LcdPrint("1");
	  }
	  else
	  {
		  LcdScreen::LcdPrint("0");
	  }

	  if (ack3)
	  {
		  LcdScreen::LcdPrint("1");
	  }
	  else
	  {
		  LcdScreen::LcdPrint("0");
	  }

	  LcdScreen::LcdToPos(0, 1);
	  LcdScreen::LcdPrintHex(byte0);
	  LcdScreen::LcdPrintHex(byte1);
	  LcdScreen::LcdPrintHex(byte2);
	  LcdScreen::LcdPrintHex(byte3);

	  ack4;
	  ack5;
	  ack6;
	  ack7;

	  volatile uint8_t bbbb = 12;

	  while (bbbb==12)
	  {

	  }


  } // @#$@#$@#%@#$#@#$# /I2C TEST @#$@#$@!#@!#@!#!#@!3





  //LcdClear();
  //LcdToPos(4,1);
  //LcdPrint("123");

  uint16_t cnt = 0;

  //DelayTimer::DelayMilliSec(10000);

  //TIM1->CNT = 10;


  //DelayTimer::DelayMicroSec(40000);

  while (1)
  {
	  //GPIOC->

	  LcdScreen::LcdToPos(0,1);
	  LcdScreen::LcdPrintNumber(cnt);
	  ++cnt;

	  //DelayTimer::DelayMicroSec(39);

	  GPIOC->BRR = 1 << 13;
	  //GPIOC->ODR = (((uint32_t)(1)) << 13);
	  //GPIOC->ODR &= ~(((uint32_t)(1)) << 13);

	  //DelayTimer::DelayMicroSec(1000);

	  //

	  //LcdDelayUs(30000);

	  DelayTimer::DelayMilliSec(50);



	  //GPIOC->ODR |= (((uint32_t)1) << 13);
	  //GPIOC->ODR = 0;
	  GPIOC->BSRR = 1 << 13;

	  DelayTimer::DelayMilliSec(50);


	  //HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);


	  //LcdDelayUs(30000);

    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}









