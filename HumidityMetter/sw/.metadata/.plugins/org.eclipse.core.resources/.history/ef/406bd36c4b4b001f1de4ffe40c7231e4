/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include "stm32f103xb.h"
#include "LcdScreen.hpp"
#include "DelayTimer.hpp"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


void InitClocks()
{
	// Use HSI = 8MHz
	// SYSCLK = HSI

	uint32_t temp = RCC->CR;
	temp &= ~(RCC_CR_PLLON | RCC_CR_CSSON | RCC_CR_HSEBYP | RCC_CR_HSEON);
	temp |= RCC_CR_HSEON;
	RCC->CR = temp;

	temp = RCC->CFGR;

	temp &= ~(RCC_CFGR_MCO);
	temp |= RCC_CFGR_MCO_SYSCLK;

	temp &= ~(RCC_CFGR_SW);
	temp |= RCC_CFGR_SW_HSI;

	// AHB = SYSCLK / 8
	temp &= ~(RCC_CFGR_HPRE);
	temp |= RCC_CFGR_HPRE_DIV8;

	// PCLK2 = SYSCLK / 1
	temp &= ~(RCC_CFGR_PPRE2);
	temp |= RCC_CFGR_PPRE2_DIV1;

	// PCLK1 = SYSCLK / 1
	temp &= ~(RCC_CFGR_PPRE1);
	temp |= RCC_CFGR_PPRE1_DIV1;

	RCC->CFGR = temp;
}

void ALTERNATIVE_FUNCTION_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
}

void PA_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
}

void PB_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
}


void PC_CLOCK_ENABLE()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
}

void InitPorts()
{
	ALTERNATIVE_FUNCTION_CLOCK_ENABLE();
	PA_CLOCK_ENABLE();
	PB_CLOCK_ENABLE();
	PC_CLOCK_ENABLE();
}





class MyClass
{
public:
	MyClass()
	{
	};
private:
};



int main(void)
{
	InitClocks();
	InitPorts();
	LcdScreen::LcdDelayUs(1500000);	// Wait for power on of LCD

	LcdScreen::LcdInit();
	//LcdInit();


  uint32_t temp = GPIOC->CRH;
  temp &= ~(((uint32_t)0b1111) << 20);
  //temp |= (((uint32_t)0b0011) << 20);
  temp |= (((uint32_t)0b0111) << 20);
  GPIOC->CRH  = temp;
//  GPIOC->CRL |= (1 << 13);

//  GPIOC->CRL


  {		// Test clock output on pin  MCO(PA8)
	  //RCC->APB2ENR |= (1 << 0) | (1 << 2);	// PA and AFIO clock enable:

	  uint32_t temp = GPIOA->CRH;
	  temp &= ~(((uint32_t)0b1111) << 0);
	  temp |= (((uint32_t)0b1011) << 0);
	  GPIOA->CRH  = temp;

//	  temp = RCC->CFGR;
//	  temp &= ~(((uint32_t)0b111) << 24);
//	  temp |= ((uint32_t)0b100) << 24;
//	  RCC->CFGR = temp;
  }

  LcdScreen::LcdPrint("Hello!!!");

  //LcdClear();
  //LcdToPos(4,1);
  //LcdPrint("123");

  //uint16_t cnt = 0;

  //DelayTimer::DelayMilliSec(10000);

  //TIM1->CNT = 10;

  while (1)
  {
	  //GPIOC->

	  //LcdScreen::LcdToPos(0,1);
	  //LcdScreen::LcdPrintNumber((uint16_t)(TIM1->CNT & 0x0000FFFF));
	  //++cnt;

	  DelayTimer::DelayMicroSec(20);

	  GPIOC->ODR &= ~(((uint32_t)(1)) << 13);

	  DelayTimer::DelayMicroSec(20);

	  //

	  //LcdDelayUs(30000);


	  GPIOC->ODR |= (((uint32_t)1) << 13);


	  //HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);


	  //LcdDelayUs(30000);

    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}









