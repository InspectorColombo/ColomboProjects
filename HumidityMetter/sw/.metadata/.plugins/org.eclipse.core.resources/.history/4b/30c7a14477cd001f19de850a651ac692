#include "AdcRead.hpp"

//#include <stdint.h>
#include "stm32f103xb.h"

#include "GpioConfigurator.hpp"

#include "LcdScreen.hpp"


//#define ADC_PORT	GPIOA		// PORT A
//#define ADC_PIN		2			// PA2 (ADC1 INPUT2)



void Show(char* msg)
{
	LcdScreen::LcdClear();
	LcdScreen::LcdToPos(0, 0);
	LcdScreen::LcdPrint(msg);
}


AdcSingleRead::AdcSingleRead(const AdcNumber adcNumber, const adcChanell adcChanell) :
		m_adcNumber(adcNumber), m_adcChanell(adcChanell)
{
	Init();
}

void AdcSingleRead::DelayMicroseconds(const uint32_t us)
{
	for(uint32_t usCnt = us; usCnt != 0; --usCnt)
	{
		asm("nop");
		asm("nop");
	}

}

void AdcSingleRead::Init()
{

	GPIOA

	// Set ADC port as analog input
	GpioConfigurator::GpioClockEnable(ADC_PORT);
	GpioConfigurator::SetGpioAnalogMode(ADC_PORT, ADC_PIN);


	uint32_t temp = RCC->CFGR;
	temp &= ~RCC_CFGR_ADCPRE_Msk;
	temp |= 0b00 << RCC_CFGR_ADCPRE_Pos; // PCLK / 2
	RCC->CFGR = temp;

	// Enable ADC1 clock
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN | RCC_APB2ENR_IOPAEN | RCC_APB2ENR_AFIOEN;

	// Turn ON ADC
	ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_EXTSEL_0 | ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_2;

	// Wait ADC turning ON
	this->DelayMicroseconds(1000);

	// Re-calibrate ADC
	ADC1->CR2 |= ADC_CR2_RSTCAL;

	// Wait for calibration end
	while ((ADC1->CR2 & ADC_CR2_RSTCAL) != 0x00)
	{
	}

	// Set 13.5cycles for channel 2
	ADC1->SMPR2 = 0b010 << ADC_SMPR2_SMP2_Pos;

	// Set only 1 channel (ADC_IN2) to conversion
	ADC1->SQR1 =  0b0000 << ADC_SQR1_L_Pos;
	ADC1->SQR2 =  0x00;
	ADC1->SQR3 =  2 << ADC_SQR3_SQ1_Pos;
}

uint16_t AdcRead::Read()
{
//	// Wait if there is conversion right now
//	while (ADC1->SR & ADC_SR_START)

	ADC1->SR &= ~ADC_SR_EOC;

//	ADC1->CR2 |= ADC_CR2_ADON;

	ADC1->CR2 |= ADC_CR2_ADON;
	ADC1->CR2 |= ADC_CR2_SWSTART;

	//Show("Step6");

	// wait for conversion end
	while ((ADC1->SR & ADC_SR_EOC) == 0)
	{
/*
 		uint32_t cr2 = ADC1->CR2;
		LcdScreen::LcdClear();
		LcdScreen::LcdToPos(0,0);
		LcdScreen::LcdPrint("CR2:");
		LcdScreen::LcdToPos(0,1);
		LcdScreen::LcdPrintHex((cr2));
		DelayMicroseconds(100000);
*/
	}

	//DelayMicroseconds(1000);


	//Show("Step7");

	uint16_t result = (uint16_t)(ADC1->DR & 0x0000FFFF);

	// Clear EOC bit if it is not cleared yet
	ADC1->SR &= ~ADC_SR_EOC;

	return result;
}






